import os
import streamlit as st
import matplotlib.pyplot as plt
import pandas as pd
from parser import SolomonFormatParser
from structure import Problem, Customer
from heuristics import HybridGWO_PSO  # Ensure this import points to the correct file

def plot_routes(problem, routes, best_cost):
    """
    Visualizes the routes generated by the optimization algorithm.
    routes: list of routes, each route is a list of customer indices.
    """
    plt.figure(figsize=(10, 8))
    depot = problem.depot
    plt.scatter(depot.x, depot.y, c='black', label='Depot', zorder=5)

    colors = plt.cm.tab20.colors

    for i, route in enumerate(routes):
        if route:
            route_customers = [problem.customers[c_idx] for c_idx in route]
            x_coords = [depot.x] + [c.x for c in route_customers] + [depot.x]
            y_coords = [depot.y] + [c.y for c in route_customers] + [depot.y]
            plt.plot(x_coords, y_coords, label=f"Route {i + 1}", color=colors[i % len(colors)])
            plt.scatter(
                [c.x for c in route_customers],
                [c.y for c in route_customers],
                label=f"Customers (Route {i + 1})",
                color=colors[i % len(colors)],
                zorder=5,
            )

            for c in route_customers:
                plt.text(c.x, c.y, str(c.id), fontsize=8, ha='right', va='bottom')

    plt.title("Vehicle Routing Problem: Routes")
    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.legend()
    plt.grid()
    st.pyplot(plt.gcf())

def plot_convergence_curve(best_cost_evolution):
    """
    Plot the convergence curve with Generation on X-axis and Best Cost on Y-axis.
    best_cost_evolution: list of best costs per generation.
    """
    plt.figure(figsize=(10, 6))  # Adjusted figure size for better horizontal orientation
    generations = range(1, len(best_cost_evolution) + 1)
    plt.plot(generations, best_cost_evolution, marker='o', linestyle='-', color='blue')
    plt.title("Convergence Curve")
    plt.xlabel("Generation")
    plt.ylabel("Best Cost")
    plt.grid(True)
    st.pyplot(plt.gcf())

def create_problem_from_manual_data(customers_df, vehicle_number, vehicle_capacity):
    """
    Constructs a Problem object from manually entered customer data.
    """
    try:
        customers = []
        parsed_customer_data = []
        for _, row in customers_df.iterrows():
            customer = Customer(
                CUST_NO=int(row['CUST_NO']),
                XCOORD=float(row['XCOORD']),
                YCOORD=float(row['YCOORD']),
                DEMAND=int(row['DEMAND']),
                READY_TIME=int(row['READY_TIME']),
                DUE_DATE=int(row['DUE_DATE']),
                SERVICE_TIME=int(row['SERVICE_TIME'])
            )
            customers.append(customer)
            parsed_customer_data.append({
                'CUST_NO': customer.CUST_NO,
                'XCOORD': customer.x,
                'YCOORD': customer.y,
                'DEMAND': customer.demand,
                'READY_TIME': customer.ready_time,
                'DUE_DATE': customer.due_date,
                'SERVICE_TIME': customer.service_time
            })
        
        # Ensure depot exists (CUST_NO=0)
        if not any(c.CUST_NO == 0 for c in customers):
            st.error("Depot (CUST_NO=0) must be included in the customer data.")
            return None

        df_customers = pd.DataFrame(parsed_customer_data)
        problem_name = "Manual Entry Instance"
        problem = Problem(problem_name, customers, vehicle_number, vehicle_capacity, df_customers)
        return problem
    except Exception as e:
        st.error(f"Error creating Problem from manual data: {e}")
        return None

def main():
    st.title("Vehicle Routing Problem Visualization")
    st.sidebar.title("Settings")

    # Option selection: Upload File or Manual Entry
    option = st.sidebar.radio("Choose Input Method", ("Upload Instance File", "Manual Customer Entry"))

    # GWO-PSO parameters sliders (defined once for both options)
    st.sidebar.subheader("GWO-PSO Parameters")
    population_size = st.sidebar.slider("Population Size", 10, 100, 50)
    generations = st.sidebar.slider("Generations", 10, 500, 100)
    w = st.sidebar.slider("Inertia Weight (w)", 0.1, 1.0, 0.7)
    c1 = st.sidebar.slider("Cognitive Parameter (c1)", 0.1, 2.0, 1.5)
    c2 = st.sidebar.slider("Social Parameter (c2)", 0.1, 2.0, 1.5)

    if option == "Upload Instance File":
        st.header("Upload Instance File")
        # File selection
        instances_folder = "../instances"
        try:
            instance_files = [file for file in os.listdir(instances_folder) if file.endswith(".txt")]
        except FileNotFoundError:
            st.error(f"The instances folder '{instances_folder}' does not exist.")
            return

        if not instance_files:
            st.error(f"No instance files found in '{instances_folder}'.")
            return

        selected_instance = st.selectbox("Select Instance File", instance_files)

        if st.button("Run Optimization"):
            instance_path = os.path.join(instances_folder, selected_instance)
            try:
                parser = SolomonFormatParser(instance_path)
                problem = parser.get_problem()
            except Exception as e:
                st.error(f"Error parsing the instance file: {e}")
                return

            st.write(f"**Instance File:** {selected_instance}")
            st.write(f"**Number of Customers:** {len(problem.customers) - 1}")
            st.write(f"**Vehicle Capacity:** {problem.vehicle_capacity}")

            st.write("Running Hybrid GWO-PSO Optimization...")

            try:
                solver = HybridGWO_PSO(
                    problem,
                    population_size=population_size,
                    generations=generations,
                    w=w,
                    c1=c1,
                    c2=c2,
                )
                best_routes, best_cost, best_cost_evolution = solver.run()
            except Exception as e:
                st.error(f"Error during optimization: {e}")
                return

            st.success(f"**Best Solution Total Cost**: {best_cost:.2f}")

            plot_routes(problem, best_routes, best_cost)
            st.write("**Routes:**")
            for i, route in enumerate(best_routes):
                if route:
                    customer_ids = [problem.customers[c_idx].id for c_idx in route]
                    st.write(f"Route {i + 1}: Depot -> {' -> '.join(map(str, customer_ids))} -> Depot")
                else:
                    st.write(f"Route {i + 1}: No customers assigned.")

            # Plot the convergence curve
            plot_convergence_curve(best_cost_evolution)

    elif option == "Manual Customer Entry":
        st.header("Enter Customer Data Manually")

        # Input vehicle information
        vehicle_number = st.number_input("Number of Vehicles", min_value=1, value=5, step=1)
        vehicle_capacity = st.number_input("Vehicle Capacity", min_value=1, value=100, step=1)

        st.subheader("Customer Data")
        st.markdown("Please enter the customer data below. Ensure that the depot (CUST_NO=0) is included.")

        # Define the initial data structure
        initial_data = {
            'CUST_NO': [0],
            'XCOORD': [50.0],
            'YCOORD': [50.0],
            'DEMAND': [0],
            'READY_TIME': [0],
            'DUE_DATE': [1000],
            'SERVICE_TIME': [0]
        }

        # Create a dataframe with initial depot data
        customers_df = st.data_editor(pd.DataFrame(initial_data), num_rows="dynamic", key="manual_customers")

        if st.button("Run Optimization"):
            # Validate the data
            if customers_df.empty:
                st.error("No customer data provided.")
                return

            required_columns = {'CUST_NO', 'XCOORD', 'YCOORD', 'DEMAND', 'READY_TIME', 'DUE_DATE', 'SERVICE_TIME'}
            if not required_columns.issubset(customers_df.columns):
                st.error(f"Missing required columns. Required columns are: {required_columns}")
                return

            # Check for duplicate CUST_NO
            if customers_df['CUST_NO'].duplicated().any():
                st.error("Duplicate CUST_NO found. Each customer must have a unique CUST_NO.")
                return

            # Create the Problem object from manual data
            problem = create_problem_from_manual_data(customers_df, vehicle_number, vehicle_capacity)
            if problem is None:
                return  # Error message already displayed

            st.write(f"**Problem Name:** {problem.name}")
            st.write(f"**Number of Customers:** {len(problem.customers) - 1}")
            st.write(f"**Vehicle Capacity:** {problem.vehicle_capacity}")

            st.write("Running Hybrid GWO-PSO Optimization...")

            try:
                solver = HybridGWO_PSO(
                    problem,
                    population_size=population_size,
                    generations=generations,
                    w=w,
                    c1=c1,
                    c2=c2,
                )
                best_routes, best_cost, best_cost_evolution = solver.run()
            except Exception as e:
                st.error(f"Error during optimization: {e}")
                return

            st.success(f"**Best Solution Total Cost**: {best_cost:.2f}")

            plot_routes(problem, best_routes, best_cost)
            st.write("**Routes:**")
            for i, route in enumerate(best_routes):
                if route:
                    customer_ids = [problem.customers[c_idx].id for c_idx in route]
                    st.write(f"Route {i + 1}: Depot -> {' -> '.join(map(str, customer_ids))} -> Depot")
                else:
                    st.write(f"Route {i + 1}: No customers assigned.")

            # Plot the convergence curve
            plot_convergence_curve(best_cost_evolution)

if __name__ == "__main__":
    main()